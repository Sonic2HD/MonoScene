using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.Xna.Framework.Graphics;

using XNAV3 = Microsoft.Xna.Framework.Vector3;
using XNAMAT = Microsoft.Xna.Framework.Matrix;

namespace MonoScene.Graphics
{
    /// <summary>
    /// Represents the state machine of a specific model instance on screen.    
    /// </summary>
    /// <remarks>
    /// <para>
    /// Lifecycle flow:<br/>
    /// <see cref="Content.ModelContent"/> ➔ <see cref="ModelTemplate"/> ➔ <b><see cref="ModelInstance"/></b>.
    /// </para>
    /// </remarks>
    public class ModelInstance
    {
        #region lifecycle

        internal ModelInstance(ModelTemplate parent)
        {
            _Parent = parent;

            _WorldMatrix = XNAMAT.Identity;

            _ModelArmature = new ArmatureInstance(_Parent._Armature);
            _ModelArmature.SetPoseTransforms();            

            _DrawableInstances = new DrawableInstance[_Parent._Drawables.Count];
            
            for (int i = 0; i < _DrawableInstances.Length; ++i)
            {
                _DrawableInstances[i] = new DrawableInstance(_Parent._Drawables[i]);
            }
        }

        #endregion

        #region data        

        public readonly ModelTemplate _Parent;        

        private XNAMAT _WorldMatrix;

        private readonly ArmatureInstance _ModelArmature;

        private readonly DrawableInstance[] _DrawableInstances;
        
        #endregion

        #region properties

        public string Name => _Parent.Name;

        public Object Tag => _Parent.Tag;

        public ArmatureInstance Armature => _ModelArmature;

        public XNAMAT WorldMatrix
        {
            get => _WorldMatrix;
            set => _WorldMatrix = value;
        }

        public Microsoft.Xna.Framework.BoundingSphere ModelBounds => _Parent.ModelBounds;

        public Microsoft.Xna.Framework.BoundingSphere WorldBounds => _Parent.ModelBounds.Transform(_WorldMatrix);        

        /// <summary>
        /// Gets the current sequence of drawing commands.
        /// </summary>
        public IReadOnlyList<DrawableInstance> DrawableInstances
        {
            get
            {
                _UpdateDrawableInstanceTransforms();
                return _DrawableInstances;
            }
        }        

        /// <summary>
        /// True if the model can be rendered.
        /// </summary>
        public bool IsVisible { get; private set; }

        /// <summary>
        /// Gets the collection of all the effects used by this model,<br/>
        /// which might be shared with other <see cref="ModelInstance"/> objects.
        /// </summary>
        public IEnumerable<Effect> SharedEffects => _Parent.SharedEffects;
        public List<Effect> OpaqueEffects { get; set; } = new List<Effect>();
        public List<Effect> TranslucidEffects { get; set; } = new List<Effect>();

        #endregion

        #region API - Armature

        public int IndexOfNode(string nodeName) { return _ModelArmature.IndexOfNode(nodeName); }

        /// <summary>
        /// Gets the matrix of a given node/bone in Model Space.
        /// </summary>
        /// <param name="nodeIndex">The index of the node/bone.</param>
        /// <returns>A matrix in model space.</returns>
        public XNAMAT GetModelMatrix(int nodeIndex) { return _ModelArmature.LogicalNodes[nodeIndex].ModelMatrix; }

        /// <summary>
        /// Gets the matrix of a given node/bone in World Space.
        /// </summary>
        /// <param name="nodeIndex">The index of the node/bone.</param>
        /// <returns>A matrix in world space.</returns>
        public XNAMAT GetWorldMatrix(int nodeIndex) { return GetModelMatrix(nodeIndex) * _WorldMatrix; }

        #endregion

        #region API - Drawing        

        private void _UpdateDrawableInstanceTransforms()
        {
            IsVisible = false;

            foreach (var dwinst in _DrawableInstances)
            {
                dwinst.Transform.Update(_ModelArmature);
                IsVisible |= dwinst.Transform.Visible;
            }
        }

        /// <summary>
        /// Draws this <see cref="MonoGameModelInstance"/> into the current <see cref="GraphicsDevice"/>.
        /// </summary>
        /// <param name="projection">The projection matrix.</param>
        /// <param name="view">The view matrix.</param>        
        public void DrawAllParts(XNAMAT projection, XNAMAT view)
        {
            foreach (var e in this.SharedEffects)
            {
                UpdateProjViewTransforms(e, projection, view);
            }

            // first we draw all the opaque meshes
            DrawOpaqueParts();

            // next, we draw all the translucid meshes
            DrawTranslucidParts();
        }

        public void DrawTranslucidParts()
        {
            foreach (var d in DrawableInstances)
            {
                var mesh = _Parent.Meshes[d.Content.MeshIndex];
                if (mesh.TranslucidEffects.Count == 0) continue;

                _SetEffectsTransforms(mesh.TranslucidEffects, _WorldMatrix, d.Transform);

                mesh.DrawTranslucid();
            }
        }

        public void DrawOpaqueParts()
        {
            foreach (var d in DrawableInstances)
            {
                var mesh = _Parent.Meshes[d.Content.MeshIndex];
                if (mesh.OpaqueEffects.Count == 0) continue;

                _SetEffectsTransforms(mesh.OpaqueEffects, _WorldMatrix, d.Transform);

                mesh.DrawOpaque();
            }
        }

        /// <summary>
        /// Applies <paramref name="worldXform"/> and <paramref name="meshXform"/> to <paramref name="effects"/>.
        /// </summary>
        /// <param name="effects">The effects to update.</param>
        /// <param name="worldXform">The new world transform.</param>
        /// <param name="meshXform">The new mesh transform containing model and skin matrices.</param>
        private void _SetEffectsTransforms(IReadOnlyCollection<Effect> effects, XNAMAT worldXform, IMeshTransform meshXform)
        {
            if (meshXform.TryGetModelMatrix(out XNAMAT modelXform))
            {
                worldXform = XNAMAT.Multiply(modelXform, worldXform);
            }

            var meshSkinMatrices = meshXform.TryGetSkinMatrices();

            foreach (var effect in effects)
            {
                UpdateWorldTransforms(effect, worldXform, meshSkinMatrices);
            }
        }        

        #endregion

        #region API - Effects

        public static void UpdateProjViewTransforms(Effect effect, XNAMAT projectionXform, XNAMAT viewXform)
        {
            if (effect is IEffectMatrices matrices)
            {
                matrices.Projection = projectionXform;
                matrices.View = viewXform;
            }
        }

        public static void UpdateWorldTransforms(Effect effect, XNAMAT worldXform, XNAMAT[] skinTransforms = null)
        {
            if (effect is IEffectMatrices matrices)
            {
                matrices.World = worldXform;
            }

            if (skinTransforms != null)
            {
                if (effect is SkinnedEffect skin)
                {
                    skin.SetBoneTransforms(skinTransforms);
                }
                else if (effect is IEffectBones iskin)
                {
                    iskin.SetBoneTransforms(skinTransforms);
                }
            }
            else
            {
                if (effect is IEffectBones iskin)
                {
                    iskin.SetBoneTransforms(null);
                }
            }
        }

        #endregion

        #region nested types

        public static IComparer<ModelInstance> GetDistanceComparer(XNAV3 origin)
        {
            return new _DistanceComparer(origin);
        }

        private struct _DistanceComparer : IComparer<ModelInstance>
        {
            public _DistanceComparer(XNAV3 origin) { _Origin = origin; }

            private readonly XNAV3 _Origin;

            public int Compare(ModelInstance x, ModelInstance y)
            {
                var xDist = (x.WorldMatrix.Translation - _Origin).LengthSquared();
                var yDist = (y.WorldMatrix.Translation - _Origin).LengthSquared();

                return xDist.CompareTo(yDist);
            }
        }

        #endregion                
    }
}
